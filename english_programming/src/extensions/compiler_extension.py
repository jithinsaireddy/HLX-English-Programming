#!/usr/bin/env python3
"""
Compiler Extension for English Programming

This module extends the NLP compiler to handle advanced English language constructs
like while loops and for-each loops, generating bytecode that works with the
VM Extension Adapter.
"""

import re
import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).absolute().parent.parent.parent.parent
sys.path.append(str(project_root))

# Import the compiler
from english_programming.src.compiler.improved_nlp_compiler import ImprovedNLPCompiler

class CompilerExtension:
    """Extension for the English Programming Compiler"""
    
    def __init__(self, compiler=None, debug=False):
        """Initialize the compiler extension"""
        self.debug = debug
        
        # Create a compiler if not provided
        self.compiler = compiler or ImprovedNLPCompiler()
        
        # Store original methods
        self.original_translate = self.compiler.translate_to_bytecode
        
        # Replace translate method
        self.compiler.translate_to_bytecode = self.enhanced_translate
        
        # Initialize patterns for English constructs
        self._init_patterns()
    
    def _init_patterns(self):
        """Initialize patterns for English language constructs"""
        # While loop patterns
        self.while_patterns = [
            r'(?i)^\s*while\s+(.+?):',
            r'(?i)^\s*as\s+long\s+as\s+(.+?):',
            r'(?i)^\s*loop\s+(?:while|when)\s+(.+?):'
        ]
        
        # For-each loop patterns
        self.foreach_patterns = [
            r'(?i)^\s*for\s+each\s+(\w+)\s+in\s+(\w+):',
            r'(?i)^\s*for\s+every\s+(\w+)\s+in\s+(\w+):',
            r'(?i)^\s*iterate\s+(?:through|over)\s+(\w+)\s+using\s+(\w+):',
            r'(?i)^\s*for\s+(\w+)\s+in\s+(\w+):'
        ]
        
        # Collection initialization patterns
        self.list_patterns = [
            r'(?i)create\s+(?:a|an)?\s*list\s+(?:called|named)\s+(\w+)\s+with\s+(?:items|values|elements)\s+(.+)'
        ]
    
    def enhanced_translate(self, line):
        """Enhanced translate method with extension support"""
        # Ensure line is a complete string, not just a character
        if not line or isinstance(line, str) and len(line.strip()) <= 1:
            return []  # Skip single characters or empty strings
            
        # Skip comments
        if line.strip().startswith('#'):
            return []
            
        # For debugging
        if self.debug:
            print(f"Translating line: '{line}'")
        
        # Process the entire line at once, not character by character
        
        # Try to match extension patterns
        extension_match = self._match_extension(line)
        
        if extension_match:
            ext_type, ext_bytecode, next_i = extension_match
            return ext_bytecode
        else:
            # Use the original compiler for standard lines
            if self.debug:
                print(f"Processing line: '{line}'")
            
            # IMPORTANT: Use our original_translate with the complete line
            line_bytecode = self.original_translate(line)
            if line_bytecode and self.debug:
                for code in line_bytecode:
                    print(f"  Generated bytecode: '{code}'")
            
            return line_bytecode or []
    
    def _match_extension(self, line):
        """Match line against extension patterns"""
        # Check for while loops
        for pattern in self.while_patterns:
            match = re.match(pattern, line)
            if match:
                condition = match.group(1)
                return self._process_while_loop(condition)
        
        # Check for for-each loops
        for pattern in self.foreach_patterns:
            match = re.match(pattern, line)
            if match:
                item_var = match.group(1)
                collection_var = match.group(2)
                return self._process_foreach_loop(item_var, collection_var)
        
        # Check for list initialization
        for pattern in self.list_patterns:
            match = re.search(pattern, line)
            if match:
                list_name = match.group(1)
                items_str = match.group(2)
                return self._process_list_init(list_name, items_str)
        
        # No match
        return None
    
    def _process_while_loop(self, condition):
        """Process a while loop"""
        # Convert English condition to bytecode condition
        bytecode_condition = self._convert_condition(condition)
        
        # Generate bytecode for while loop
        bytecode = [
            "WHILE_START",
            f"IF {bytecode_condition}"
        ]
        
        # Next line is after the while loop header
        next_i = 1
        
        return "while", bytecode, next_i
    
    def _process_foreach_loop(self, item_var, collection_var):
        """Process a for-each loop"""
        # Generate bytecode for for-each loop
        bytecode = [
            f"FOR_EACH {item_var} {collection_var}"
        ]
        
        # Next line is after the for-each loop header
        next_i = 1
        
        return "foreach", bytecode, next_i
    
    def _process_list_init(self, list_name, items_str):
        """Process list initialization"""
        # Parse items
        items = []
        
        # Check for quoted items
        quoted_items = re.findall(r'"([^"]*)"', items_str)
        if quoted_items:
            items = [f'"{item}"' for item in quoted_items]
        else:
            # Try splitting by commas and 'and'
            items = [item.strip() for item in re.split(r',|\s+and\s+', items_str)]
        
        # Generate bytecode for list initialization
        items_list = "[" + ", ".join(items) + "]"
        bytecode = [f"SET {list_name} {items_list}"]
        
        # Only process this line
        next_i = 1
        
        return "list", bytecode, next_i
    
    def _convert_condition(self, condition):
        """Convert English condition to bytecode condition"""
        # Replace English operators with symbols
        replacements = [
            (r'is\s+less\s+than\s+or\s+equal\s+to', '<='),
            (r'is\s+greater\s+than\s+or\s+equal\s+to', '>='),
            (r'is\s+less\s+than', '<'),
            (r'is\s+greater\s+than', '>'),
            (r'is\s+equal\s+to', '=='),
            (r'equals', '=='),
            (r'is\s+not\s+equal\s+to', '!='),
            (r'is\s+not', '!='),
            (r'is', '==')
        ]
        
        result = condition.lower()
        for pattern, replacement in replacements:
            result = re.sub(pattern, replacement, result)
        
        # Clean up by ensuring spaces around operators
        operators = ['==', '!=', '<=', '>=', '<', '>']
        for op in operators:
            result = result.replace(op, f' {op} ')
        
        # Remove extra spaces
        result = re.sub(r'\s+', ' ', result).strip()
        
        return result
"""
Compiler Extension for English Programming

This module extends the improved NLP compiler to handle additional English-language
constructs related to advanced control flow, object-oriented programming, and
module systems. It properly processes complete English sentences and generates
bytecode that is compatible with the VM extension adapter.
"""

import os
import sys
import re
from pathlib import Path

# Add the project root to the path
project_root = Path(__file__).absolute().parent.parent.parent.parent
sys.path.append(str(project_root))

# Import the compiler
from english_programming.src.compiler.improved_nlp_compiler import ImprovedNLPCompiler

class EnglishCompilerExtension:
    """
    Extension for the Improved NLP Compiler
    
    This class enhances the compiler to handle advanced English constructs:
    1. While loops (while condition: statements)
    2. For-each loops (for each item in collection: statements)
    3. Classes and OOP (create class, define methods, create objects)
    4. Module imports (import module as alias)
    
    It generates extended bytecode that the VM extension adapter can process.
    """
    
    def __init__(self, compiler=None, debug=False):
        """
        Initialize the compiler extension
        
        Args:
            compiler (ImprovedNLPCompiler, optional): Compiler to extend
            debug (bool): Enable debugging output
        """
        self.debug = debug
        
        # Create new compiler if not provided
        self.compiler = compiler if compiler else ImprovedNLPCompiler()
        
        # Store original translate method
        self.original_translate = self.compiler.translate_to_bytecode
        
        # Override compiler's translate method
        self.compiler.translate_to_bytecode = self.extended_translate
        
        # Pattern matchers for extended language features
        self.while_pattern = re.compile(r'^\s*while\s+(.+):', re.IGNORECASE)
        self.for_each_pattern = re.compile(r'^\s*for\s+each\s+(\w+)\s+in\s+(\w+):', re.IGNORECASE)
        self.class_pattern = re.compile(r'^\s*create\s+class\s+(\w+)(?:\s+that\s+extends\s+(\w+))?:', re.IGNORECASE)
        self.method_pattern = re.compile(r'^\s*define\s+method\s+(\w+)(?:\s+with\s+(?:inputs|parameters)\s+(.+))?:', re.IGNORECASE)
        self.create_object_pattern = re.compile(r'^\s*create\s+(?:a|an)?\s+(\w+)\s+object\s+called\s+(\w+)(?:\s+with\s+(?:inputs|parameters)\s+(.+))?', re.IGNORECASE)
        self.call_method_pattern = re.compile(r'^\s*call\s+(?:the\s+)?(\w+)\s+method\s+on\s+(\w+)(?:\s+(?:with|and)\s+(?:input|inputs|parameter|parameters|value|values|arguments)\s+(.+))?', re.IGNORECASE)
        self.import_pattern = re.compile(r'^\s*import\s+(?:the\s+)?(\w+)\s+module(?:\s+as\s+(\w+))?', re.IGNORECASE)
        
        if self.debug:
            print("Compiler Extension initialized")
    
    def extended_translate(self, lines):
        """
        Enhanced translate_to_bytecode method with extension support
        
        Args:
            lines (list or str): Lines of English code to translate
            
        Returns:
            list: Generated bytecode with extension support
        """
        # Handle both string and list input
        if isinstance(lines, str):
            lines = [lines]
        
        # Process lines
        bytecode = []
        i = 0
        
        while i < len(lines):
            line = lines[i].strip()
            
            # Skip empty lines and comments
            if not line or line.startswith('#'):
                i += 1
                continue
            
            # Check for advanced language features
            
            # While loop
            while_match = self.while_pattern.match(line)
            if while_match:
                condition = while_match.group(1)
                block_bytecode, new_i = self._process_block(lines, i, "while")
                
                if block_bytecode:
                    bytecode.extend(self._generate_while_loop(condition, block_bytecode))
                    i = new_i
                    continue
            
            # For-each loop
            for_each_match = self.for_each_pattern.match(line)
            if for_each_match:
                item_var = for_each_match.group(1)
                collection_var = for_each_match.group(2)
                block_bytecode, new_i = self._process_block(lines, i, "for")
                
                if block_bytecode:
                    bytecode.extend(self._generate_for_each_loop(item_var, collection_var, block_bytecode))
                    i = new_i
                    continue
            
            # Class definition
            class_match = self.class_pattern.match(line)
            if class_match:
                class_name = class_match.group(1)
                parent_class = class_match.group(2)
                block_bytecode, new_i = self._process_block(lines, i, "class")
                
                if block_bytecode:
                    bytecode.extend(self._generate_class_definition(class_name, parent_class, block_bytecode))
                    i = new_i
                    continue
            
            # Create object
            create_object_match = self.create_object_pattern.match(line)
            if create_object_match:
                class_name = create_object_match.group(1)
                object_name = create_object_match.group(2)
                params = create_object_match.group(3)
                
                param_list = []
                if params:
                    param_list = [p.strip() for p in params.split('and')]
                
                bytecode.extend(self._generate_create_object(class_name, object_name, param_list))
                i += 1
                continue
            
            # Method call
            call_method_match = self.call_method_pattern.match(line)
            if call_method_match:
                method_name = call_method_match.group(1)
                object_name = call_method_match.group(2)
                params = call_method_match.group(3)
                
                param_list = []
                if params:
                    param_list = [p.strip() for p in params.split('and')]
                
                bytecode.extend(self._generate_call_method(object_name, method_name, None, param_list))
                i += 1
                continue
            
            # Import module
            import_match = self.import_pattern.match(line)
            if import_match:
                module_name = import_match.group(1)
                alias = import_match.group(2) or module_name
                
                bytecode.extend(self._generate_import_module(module_name, alias))
                i += 1
                continue
            
            # Fall back to the original compiler for standard instructions
            standard_bytecode = self.original_translate([line])
            if standard_bytecode:
                bytecode.extend(standard_bytecode)
            elif self.debug:
                print(f"Warning: Could not translate line: {line}")
            
            i += 1
        
        return bytecode
    
    def _process_block(self, lines, start_idx, block_type):
        """
        Process an indented block of code
        
        Args:
            lines (list): Lines of code
            start_idx (int): Index of the block header
            block_type (str): Type of block ('while', 'for', 'class', 'method')
            
        Returns:
            tuple: (block_bytecode, new_index)
        """
        # Skip the header line
        i = start_idx + 1
        block_lines = []
        
        # Start indentation tracking
        if i < len(lines):
            first_line = lines[i]
            indent_level = len(first_line) - len(first_line.lstrip())
            
            # Special handling for method blocks in class definitions
            if block_type == "class":
                class_bytecode = []
                
                while i < len(lines):
                    line = lines[i]
                    current_indent = len(line) - len(line.lstrip())
                    
                    # End of class definition
                    if line.strip() and current_indent < indent_level:
                        break
                    
                    # Check for method definitions within the class
                    method_match = self.method_pattern.match(line.lstrip())
                    if method_match and current_indent == indent_level:
                        method_name = method_match.group(1)
                        params = method_match.group(2)
                        param_list = []
                        if params:
                            param_list = [p.strip() for p in params.split('and')]
                        
                        method_bytecode, new_i = self._process_block(lines, i, "method")
                        if method_bytecode:
                            class_bytecode.append(f"METHOD_DEF {method_name} {' '.join(param_list)}")
                            class_bytecode.extend(method_bytecode)
                            class_bytecode.append("METHOD_END")
                            i = new_i
                            continue
                    
                    # Regular class member (non-method)
                    if line.strip() and current_indent == indent_level:
                        standard_bytecode = self.original_translate([line.lstrip()])
                        if standard_bytecode:
                            class_bytecode.extend(standard_bytecode)
                    
                    i += 1
                
                return class_bytecode, i
            
            # Process regular blocks (while, for, method)
            while i < len(lines):
                line = lines[i]
                current_indent = len(line) - len(line.lstrip())
                
                # End of block
                if line.strip() and current_indent < indent_level:
                    break
                
                # Add block line (only if it has content)
                if line.strip() and current_indent >= indent_level:
                    block_lines.append(line.lstrip())  # Remove indent for processing
                
                i += 1
        
        # Process the block lines to bytecode
        block_bytecode = self.extended_translate(block_lines)
        
        return block_bytecode, i
    
    def _generate_while_loop(self, condition, block_bytecode):
        """
        Generate extended bytecode for a while loop
        
        Args:
            condition (str): Loop condition
            block_bytecode (list): Body of the loop
            
        Returns:
            list: Generated bytecode
        """
        # Normalize the condition
        # Convert conditions like "x is less than 10" to "x < 10"
        condition = self._normalize_condition(condition)
        
        bytecode = [
            "WHILE_START",
            f"CONDITION {condition}"
        ]
        
        # Add the loop body
        bytecode.extend(block_bytecode)
        
        # End the loop
        bytecode.append("WHILE_END")
        
        return bytecode
    
    def _generate_for_each_loop(self, item_var, collection_var, block_bytecode):
        """
        Generate extended bytecode for a for-each loop
        
        Args:
            item_var (str): Variable for each item
            collection_var (str): Collection to iterate
            block_bytecode (list): Body of the loop
            
        Returns:
            list: Generated bytecode
        """
        bytecode = [
            f"FOR_EACH {item_var} {collection_var}"
        ]
        
        # Add the loop body
        bytecode.extend(block_bytecode)
        
        # End the loop
        bytecode.append("FOR_END")
        
        return bytecode
    
    def _generate_class_definition(self, class_name, parent_class, block_bytecode):
        """
        Generate extended bytecode for a class definition
        
        Args:
            class_name (str): Name of the class
            parent_class (str): Name of the parent class (can be None)
            block_bytecode (list): Class body
            
        Returns:
            list: Generated bytecode
        """
        if parent_class:
            bytecode = [f"CLASS_DEF {class_name} {parent_class}"]
        else:
            bytecode = [f"CLASS_DEF {class_name}"]
        
        # Add class body
        bytecode.extend(block_bytecode)
        
        # End class definition
        bytecode.append("CLASS_END")
        
        return bytecode
    
    def _generate_create_object(self, class_name, object_name, params):
        """
        Generate extended bytecode for object creation
        
        Args:
            class_name (str): Name of the class
            object_name (str): Name for the new object
            params (list): Constructor parameters
            
        Returns:
            list: Generated bytecode
        """
        bytecode = [f"CREATE_OBJECT {class_name} {object_name}"]
        
        # Add parameters if any
        if params:
            for param in params:
                bytecode[-1] += f" {param}"
        
        return bytecode
    
    def _generate_call_method(self, object_name, method_name, result_var, params):
        """
        Generate extended bytecode for method call
        
        Args:
            object_name (str): Name of the object
            method_name (str): Name of the method
            result_var (str): Variable to store result (can be None)
            params (list): Method parameters
            
        Returns:
            list: Generated bytecode
        """
        if result_var:
            bytecode = [f"CALL_METHOD {object_name} {method_name} {result_var}"]
        else:
            bytecode = [f"CALL_METHOD {object_name} {method_name}"]
        
        # Add parameters if any
        if params:
            for param in params:
                bytecode[-1] += f" {param}"
        
        return bytecode
    
    def _generate_import_module(self, module_name, alias):
        """
        Generate extended bytecode for module import
        
        Args:
            module_name (str): Name of the module
            alias (str): Alias for the module
            
        Returns:
            list: Generated bytecode
        """
        return [f"IMPORT_MODULE {module_name} {alias}"]
    
    def _normalize_condition(self, condition):
        """
        Normalize an English condition to bytecode syntax
        
        Args:
            condition (str): English condition (e.g., "x is less than 5")
            
        Returns:
            str: Normalized condition (e.g., "x < 5")
        """
        # Common English condition patterns
        patterns = [
            (r'(\w+)\s+is\s+less\s+than\s+or\s+equal\s+to\s+(\w+)', r'\1 <= \2'),
            (r'(\w+)\s+is\s+less\s+than\s+(\w+)', r'\1 < \2'),
            (r'(\w+)\s+is\s+greater\s+than\s+or\s+equal\s+to\s+(\w+)', r'\1 >= \2'),
            (r'(\w+)\s+is\s+greater\s+than\s+(\w+)', r'\1 > \2'),
            (r'(\w+)\s+is\s+equal\s+to\s+(\w+)', r'\1 == \2'),
            (r'(\w+)\s+equals\s+(\w+)', r'\1 == \2'),
            (r'(\w+)\s+is\s+not\s+equal\s+to\s+(\w+)', r'\1 != \2'),
            (r'(\w+)\s+is\s+not\s+(\w+)', r'\1 != \2')
        ]
        
        result = condition.lower()
        for pattern, replacement in patterns:
            result = re.sub(pattern, replacement, result)
        
        return result

# Standalone test function
def test_compiler_extension():
    """Test the compiler extension"""
    extension = EnglishCompilerExtension(debug=True)
    
    # Create a simple English program with extensions
    test_file = "compiler_test.nl"
    english_code = """
# Test program for compiler extensions

# Initialize variables
create a variable called counter and set it to 1
create a variable called sum and set it to 0

# While loop test
print "Testing while loop:"
while counter is less than or equal to 5:
    print counter
    add counter to sum and store the result in sum
    add 1 to counter and store the result in counter

print "Final sum:"
print sum

# For-each loop test
create a variable called fruits and set it to ["apple", "banana", "cherry"]
print "Testing for-each loop:"
for each fruit in fruits:
    print "Current fruit:"
    print fruit

# Class definition test
create class Person:
    define method constructor with parameters name and age:
        set the name property of self to name
        set the age property of self to age
    
    define method greet:
        print "Hello, my name is"
        print self.name
        print "and I am"
        print self.age
        print "years old"

# Object creation and method call
create a Person object called john with parameters "John Doe" and 30
call the greet method on john

print "Test completed"
"""
    
    with open(test_file, "w") as f:
        f.write(english_code)
    
    # Compile the English program
    lines = english_code.strip().split('\n')
    bytecode = extension.extended_translate(lines)
    
    # Write the bytecode to a file
    bytecode_file = "compiler_test.nlc"
    with open(bytecode_file, "w") as f:
        for line in bytecode:
            f.write(line + "\n")
    
    print(f"Generated bytecode:")
    for line in bytecode:
        print(f"  {line}")
    
    print(f"\nCompiled {test_file} to {bytecode_file}")
    
    # Clean up
    if os.path.exists(test_file):
        os.remove(test_file)

if __name__ == "__main__":
    test_compiler_extension()
