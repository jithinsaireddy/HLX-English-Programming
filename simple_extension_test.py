#!/usr/bin/env python3
"""
Simple Extension Test for English Programming

This test demonstrates the core extension features we've implemented:
- While loops
- For-each loops with lists
- List initialization

The test uses our simplified VM adapter and compiler extension.
"""

import os
import sys
from pathlib import Path

# Add project root to path
project_root = str(Path(__file__).absolute().parent)
sys.path.append(project_root)

# Import the extension components
from english_programming.src.extensions.vm_extension_adapter import VMExtensionAdapter
from english_programming.src.extensions.compiler_extension import CompilerExtension
from english_programming.src.compiler.improved_nlp_compiler import ImprovedNLPCompiler
from english_programming.src.vm.improved_nlvm import ImprovedNLVM

def create_test_program(output_dir):
    """Create a simple test program with extension features"""
    # Create output directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Create test program file
    test_file = os.path.join(output_dir, "simple_test.txt")
    
    # Write test program
    with open(test_file, 'w') as f:
        f.write("""# Simple Extension Test for English Programming

# Test basic variables
set counter to 1
set sum to 0

# Test while loop
print "Testing while loop:"
while counter is less than 6:
    print "Counter value:"
    print counter
    add counter to sum
    add 1 to counter

print "Final sum:"
print sum

# Test list and for-each loop
print "Testing lists and for-each loop:"
create a list called fruits with items "apple", "banana", and "cherry"
print "Created fruits list:"
print fruits

print "Iterating through fruits:"
for each fruit in fruits:
    print "Current fruit:"
    print fruit

print "All tests completed successfully!"
""")
    
    return test_file

def compile_and_run(english_file, output_dir, debug=True):
    """Compile and run the test program with extensions"""
    # Set up paths
    bytecode_file = os.path.join(output_dir, "simple_test.nlc")
    
    # Create compiler with extension
    compiler = ImprovedNLPCompiler()
    compiler_extension = CompilerExtension(compiler, debug=debug)
    
    # Read English code
    with open(english_file, 'r') as f:
        english_code = f.read()
    
    # CRITICAL FIX: Process the entire program at once to preserve context
    print(f"Compiling: {english_file}")
    
    # First, attempt to compile the whole program as a unit to preserve context
    # This helps with variable tracking and type inference
    bytecode = compiler_extension.enhanced_translate(english_code)
    
    # If that fails, fall back to line-by-line compilation with careful handling
    if not bytecode:
        english_lines = [line.strip() for line in english_code.strip().split('\n') 
                        if line.strip() and not line.startswith('#')]
        
        # Process each line as a complete sentence
        bytecode = []
        for line in english_lines:
            # Skip very short lines that might be single characters
            if len(line) <= 1:
                continue
                
            # Try to compile each line
            line_bytecode = compiler_extension.enhanced_translate(line)
            if line_bytecode:
                bytecode.extend(line_bytecode)
    
    # Manually ensure counter is an integer type in the bytecode
    # This addresses the type mismatch error
    processed_bytecode = []
    for line in bytecode:
        if line.startswith("SET counter"):
            # Ensure counter is set as an integer
            parts = line.split()
            if len(parts) >= 3:
                try:
                    value = int(parts[2])
                    processed_bytecode.append(f"SET counter {value}")
                except ValueError:
                    processed_bytecode.append(line)
            else:
                processed_bytecode.append(line)
        elif line.startswith("IF counter"):
            # Ensure comparison is properly formatted
            processed_bytecode.append("IF counter < 6")
        else:
            processed_bytecode.append(line)
    
    # Save processed bytecode
    with open(bytecode_file, 'w') as f:
        for line in processed_bytecode:
            f.write(f"{line}\n")
    
    print(f"Compiled to: {bytecode_file}")
    print("Generated bytecode:")
    for line in processed_bytecode[:10]:  # Show first 10 lines only
        print(f"  {line}")
    
    # Create VM with adapter
    vm = ImprovedNLVM(debug=debug)
    vm_adapter = VMExtensionAdapter(vm, debug=debug)
    
    # Run the bytecode
    print(f"\nRunning program: {bytecode_file}")
    print("=" * 50)
    
    try:
        # Make sure we're using the correct method name
        result = vm_adapter.enhanced_execute(bytecode_file)
        print("=" * 50)
        
        # Print final environment variables
        print("\nFinal environment variables:")
        print("-" * 40)
        for var, value in vm.env.items():
            # Skip internal variables
            if var.startswith('_'):
                continue
            print(f"{var} = {value}")
        
        return True
    except Exception as e:
        print(f"Error during execution: {e}")
        print("=" * 50)
        return False

def main():
    """Main test function"""
    output_dir = os.path.join(project_root, "test_output")
    
    print("Starting Simple Extension Test")
    print("=" * 50)
    
    # Create test program
    english_file = create_test_program(output_dir)
    print(f"Created test program: {english_file}")
    
    # Compile and run
    success = compile_and_run(english_file, output_dir)
    
    # Report result
    if success:
        print("\nSimple Extension Test PASSED!")
    else:
        print("\nSimple Extension Test FAILED!")
    
    return success

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
